# üí° Introdu√ß√£o

## Objetivo ##
Este reposit√≥rio cont√©m uma estrutura de arquivos `hcl` para o provisionamento de infraestrutura na AWS. Esta arquitetura √© composta pelo EKS organizado em um √∫nico m√≥dulos distinto para facilitar a manuten√ß√£o e escalabilidade.

## üì¶ Estrutura ##

- *eks:* Provisionamento do cluster EKS.

### Pr√©-requisitos

- *AWS CLI:* Configurado com um perfil para autentica√ß√£o.
- *Terraform:* Certifique-se de que a vers√£o instalada seja compat√≠vel com os provedores declarados (~> 4.0).

### Configura√ß√£o Inicial

- *Configurar o AWS CLI:* Execute ¬¥aws configure¬¥ e configure o perfil de autentica√ß√£o com as credenciais apropriadas para provisionar a infraestrutura na regi√£o `us-east-1` juntamente com uma *access_key* e uma *secret_key*.
- *Configurar o backend do Terraform:* A pasta `eks` possui um backend remoto cujo state √© salvo em um Workspace do Terraform Cloud, por isso √© necess√°rio em execu√ß√µes locais executar o [Terraform Login](https://developer.hashicorp.com/terraform/tutorials/cloud-get-started/cloud-login#start-the-login-flow).

### Como as Actons Funcionam?
- Para executar o Apply ou Destroy em sua infraestrutura basta selcionar o workspace `Terraform Apply/Destroy`em seguida clique em `run workflow`. Selecione a√ß√£o *(apply ou destroy)*, por √∫ltimo escolha o m√≥dulo desejado.
- As Actions utilizam um backend remoto da Hascorp para guardar o arquivo do State, para isso caso seja necess√°rio gerenciar a infraestrutura por uma outra conta de AWS √© necess√°rio alterar dentro do Workflow criado no Terraform Cloud as v√©riaveis de ambiente *(AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY)* al√©m do `HASHICORP_TOKEN` que ser√° gerado em sua respectiva conta.

- Para integrar todo este backend com o terraform preciso declar esta estrutura no arquivo `providers.tf`:

```hcl
  backend "remote" {
    hostname     = "app.terraform.io"
    organization = "sua-org"

    workspaces {
      name = "seu-workspace"
    }
  }
```

- *hostname* = Sempre vai ser `app.terraform.io`
- *organization* = Aqui declaramos a organizarion em que est√£o inseridos os workspaces, caso necess√°rio troque este valor para o sua organization criada posteriormente.
- *workspaces* = Aqui declaramos o nome do workspace, caso necess√°rio troque este valor para o seu workspace criado posteriormente.


## Como Provisionar Recursos ##

### Provisionar o Cluster EKS

Acesse e execute os seguintes comandos na pasta `eks:`

```bash
terraform init
terraform apply

```

Claro, Darlei! Aqui est√° uma documenta√ß√£o clara e objetiva sobre o processo de **habilitar o OIDC via `eksctl`** e **ajustar o Terraform (`irsa.tf`) para refletir o novo endpoint** do cluster EKS.

---

# üìò Configurando IRSA com OIDC via `eksctl` + Terraform

## ‚úÖ Vis√£o geral

Este processo habilita o OIDC no cluster Amazon EKS usando `eksctl` e ajusta o c√≥digo Terraform (`irsa.tf`) para autenticar workloads via IRSA (IAM Roles for Service Accounts).

---

## üß© Pr√©-requisitos

- Cluster EKS j√° provisionado
- `eksctl` instalado ([guia oficial](https://eksctl.io/introduction/installation/))
- Acesso ao AWS CLI configurado (`~/.aws/credentials`)
- Terraform CLI (vers√£o compat√≠vel com o Terraform Cloud)

---

## ‚úÖ Etapa 1: Habilitar o OIDC Provider via `eksctl`

> Quando o cluster √© recriado, ele recebe um **novo OIDC issuer** e um novo endpoint. √â necess√°rio habilitar esse novo issuer no IAM da conta AWS.

### üìå Comando:

```bash
eksctl utils associate-iam-oidc-provider \
  --region us-east-1 \
  --cluster video-processor-eks-cluster \
  --approve
```

Esse comando:

- Detecta o `issuer` do cluster
- Cria o provedor OIDC correspondente no IAM
- Garante que o IRSA possa usar `AssumeRoleWithWebIdentity`

---

## ‚úÖ Etapa 2: Atualizar o Terraform (`irsa.tf`)

Ap√≥s a cria√ß√£o do novo OIDC Provider, √© necess√°rio **referenci√°-lo manualmente no Terraform**, j√° que ele **n√£o ser√° gerenciado diretamente pelo Terraform**.

### ‚úÖ Bloco Terraform atualizado (`irsa.tf`):

```hcl
resource "aws_iam_role" "irsa_sqs_role" {
  name = "notificacao-api-irsa-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Effect = "Allow",
        Principal = {
          Federated = "arn:aws:iam::585008076257:oidc-provider/oidc.eks.us-east-1.amazonaws.com/id/7A537DEE0765B3CB34001EEAE1288D8D"
        },
        Action = "sts:AssumeRoleWithWebIdentity",
        Condition = {
          StringEquals = {
            "oidc.eks.us-east-1.amazonaws.com/id/7A537DEE0765B3CB34001EEAE1288D8D:sub" = "system:serviceaccount:fast-video:notificacao-api-sa",
            "oidc.eks.us-east-1.amazonaws.com/id/7A537DEE0765B3CB34001EEAE1288D8D:aud" = "sts.amazonaws.com"
          }
        }
      }
    ]
  })
}

resource "aws_iam_policy" "sqs_policy" {
  name = "notificacao-api-sqs-policy"

  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Effect = "Allow",
        Action = [
          "sqs:ReceiveMessage",
          "sqs:DeleteMessage",
          "sqs:GetQueueAttributes"
        ],
        Resource = "*"
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "attach_sqs_policy" {
  role       = aws_iam_role.irsa_sqs_role.name
  policy_arn = aws_iam_policy.sqs_policy.arn
}
```

> ‚ö†Ô∏è **Substitua o ID do OIDC pelo atual**, que pode ser verificado com:

```bash
aws eks describe-cluster \
  --region us-east-1 \
  --name video-processor-eks-cluster \
  --query "cluster.identity.oidc.issuer" \
  --output text
```

---

## ‚úÖ Etapa 3: Aplicar Terraform

Ap√≥s editar o `irsa.tf`:

```bash
terraform init
terraform apply
```

---

## ‚úÖ Etapa 4: Criar o `ServiceAccount` com anota√ß√£o IRSA

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: notificacao-api-sa
  namespace: fast-video
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::585008076257:role/notificacao-api-irsa-role
```

Aplique com:

```bash
kubectl apply -f serviceaccount.yaml
```

---

## ‚úÖ Etapa 5: Garantir que o pod est√° usando o `ServiceAccount`

No `Deployment` da sua aplica√ß√£o:

```yaml
spec:
  serviceAccountName: notificacao-api-sa
```

Depois, reinicie o pod:

```bash
kubectl rollout restart deployment notificacao-api -n fast-video
```

---

## ‚úÖ Valida√ß√£o final

Execute:

```bash
kubectl exec -it <pod-name> -n fast-video -- env | grep AWS
```

Voc√™ deve ver:

```
AWS_ROLE_ARN=arn:aws:iam::585008076257:role/notificacao-api-irsa-role
AWS_WEB_IDENTITY_TOKEN_FILE=/var/run/secrets/eks.amazonaws.com/serviceaccount/token
```

Isso confirma que o pod est√° autenticado com IRSA üéØ

---

Se quiser, posso te ajudar a colocar isso em um `README.md` ou Wiki para documentar no reposit√≥rio. Deseja?